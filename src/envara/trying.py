###############################################################################

import os
import re
import fnmatch
import subprocess
import shlex
from typing import ClassVar


class Trying:
    """
    Class for string expansions
    """

    ###########################################################################
    # Generated by AI with my minor generalisation
    ###########################################################################

    @staticmethod
    def expand_posix(
        input: str,
        args: list[str] | None = None,
        vars: dict[str, str] | None = os.environ,
        exp_chr: str = "$",
        esc_chr: str = "\\",
        allow_subprocess: bool = True,
        allow_shell: bool = True,
        subprocess_timeout: float | None = None,
    ) -> str:
        """
        Expand POSIX-like parameter expansions in the input string. Supported
        constructs:
          - Basic: $NAME, ${NAME}, $1 (positional args), $$ (PID)
          - Length: ${#NAME}
          - Defaults and alternatives: ${NAME:-word}, ${NAME-word}, ${NAME:+word}
          - Error: ${NAME:?message}
          - Substring: ${NAME:offset[:length]} (offset and length are integers)
        Unset variables without a default leave the original pattern unchanged.
        A backslash before $ escapes it (e.g., \$NAME -> $NAME literal).
        Nested expansions in default/alternative words are supported.

        :param input: string to expand
        :param args: positional arguments list (1-based indices)
        :param vars: dictionary with variables (defaults to os.environ)
        :param exp_chr: character marking the expansion start (default: dollar sign)
        :param esc_chr: escaping character (default: backslash)
        :return: expanded string
        """

        if input is None:
            return ""

        if vars is None:
            vars = os.environ

        s = input
        res: list[str] = []
        i = 0
        inp_len = len(s)
        bktick = "`"
        is_bktick_cmd = bktick != esc_chr

        def get_var(name: str):
            return vars.get(name) if vars is not None else os.environ.get(name)

        def eval_braced(inner: str) -> str:
            # Length: #{NAME}
            if inner.startswith("#"):
                name = inner[1:]
                val = get_var(name)
                if val is None:
                    # leave original
                    return f"{exp_chr}{{{inner}}}"
                return str(len(val))

            # Parse name
            m = re.match(r'^([A-Za-z_][A-Za-z0-9_]*)', inner)
            if not m:
                return f"{exp_chr}{{{inner}}}"
            name = m.group(1)
            rest = inner[m.end():]

            val = get_var(name)
            is_set = val is not None
            is_null = (val == "") if is_set else False

            # Substring: :offset[:length]
            sm = re.match(r'^:(-?\d+)(?::(-?\d+))?$', rest)
            if sm:
                offset = int(sm.group(1))
                length = int(sm.group(2)) if sm.group(2) is not None else None
                if not is_set:
                    return f"{exp_chr}{{{inner}}}"
                text = val
                if offset < 0:
                    offset = len(text) + offset
                    if offset < 0:
                        offset = 0
                if length is None:
                    return text[offset:]
                return text[offset:offset + length]

            # Parameter expansion operators
            # Assignment operators: := (set if unset or null), = (set if unset)
            if rest.startswith(":=") or rest.startswith("="):
                assign_colon = rest.startswith(":=")
                word = rest[2:] if assign_colon else rest[1:]
                # if unset or (colon and null), assign
                if (not is_set) or (assign_colon and is_null):
                    new_val = Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                    try:
                        if vars is not None:
                            vars[name] = new_val
                    except Exception:
                        pass
                    return new_val
                return val

            # Pattern removals: #, ## (prefix) and %, %% (suffix)
            if rest.startswith("##") or rest.startswith("#"):
                pattern = rest[2:] if rest.startswith("##") else rest[1:]
                if not is_set:
                    return f"{exp_chr}{{{inner}}}"
                text = val
                best_i = None
                for i in range(0, len(text) + 1):
                    if fnmatch.fnmatchcase(text[0:i], pattern):
                        if rest.startswith("##"):
                            # longest
                            best_i = i
                        else:
                            # shortest
                            best_i = i
                            break
                if best_i is None:
                    return text
                return text[best_i:]
            if rest.startswith("%%") or rest.startswith("%"):
                pattern = rest[2:] if rest.startswith("%%") else rest[1:]
                if not is_set:
                    return f"{exp_chr}{{{inner}}}"
                text = val
                best_i = None
                for i in range(0, len(text) + 1):
                    # suffix of length i starting at len(text)-i
                    sub = text[len(text) - i:]
                    if fnmatch.fnmatchcase(sub, pattern):
                        if rest.startswith("%%"):
                            best_i = i
                        else:
                            best_i = i
                            break
                if best_i is None:
                    return text
                return text[:len(text) - best_i]

            # Substitutions: optional anchor (# for prefix, % for suffix),
            # then / (first) or // (all)
            # Examples: ${var/pat/repl}, ${var//pat/repl}, ${var/#pat/repl}, ${var/%pat/repl}
            anchor = None
            r = rest
            if r and r[0] in ("#", "%"):
                anchor = r[0]
                r = r[1:]

            pat = None
            repl = None
            is_all = False

            # Forms:
            # 1) //pattern/repl  => is_all True
            # 2) /pattern/repl   => single replacement
            # 3) pattern/repl    => anchored forms (#/%prefix) or normal without leading slash
            if r.startswith("//"):
                is_all = True
                part = r[2:]
                if "/" in part:
                    pat, repl = part.split("/", 1)
            elif r.startswith("/"):
                part = r[1:]
                if "/" in part:
                    pat, repl = part.split("/", 1)
            elif "/" in r:
                # typical anchored form: #{pattern}/{repl} or %{pattern}/{repl}
                pat, repl = r.split("/", 1)

            # If the pattern itself starts with an anchor char, treat that as anchor
            if pat and pat[0] in ("#", "%"):
                anchor = pat[0]
                pat = pat[1:]

            if (pat is None) or (repl is None):
                # no substitution-like construct
                pass
            else:
                if not is_set:
                    return f"{exp_chr}{{{inner}}}"

                # convert glob pattern to regex core
                core = fnmatch.translate(pat)
                # strip outer (?s: ... )\Z
                if core.startswith("(?s:") and core.endswith(")\\Z"):
                    core = core[4:-3]

                repl_eval = Trying.expand_posix(repl, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)

                # Anchored prefix substitution: replace the shortest matching prefix
                if anchor == "#":
                    text = val
                    if is_all:
                        # Iteratively replace as long as progress is made
                        while True:
                            changed = False
                            for i in range(1, len(text) + 1):
                                if fnmatch.fnmatchcase(text[:i], pat):
                                    new_text = repl_eval + text[i:]
                                    if new_text == text:
                                        # No progress — avoid infinite loop
                                        changed = False
                                        break
                                    text = new_text
                                    changed = True
                                    break
                            if not changed:
                                break
                        return text
                    else:
                        for i in range(1, len(text) + 1):
                            if fnmatch.fnmatchcase(text[:i], pat):
                                return repl_eval + text[i:]
                        return val

                # Anchored suffix substitution: replace the shortest matching suffix
                if anchor == "%":
                    text = val
                    if is_all:
                        # Iteratively replace as long as progress is made
                        while True:
                            changed = False
                            for i in range(1, len(text) + 1):
                                sub = text[len(text) - i:]
                                if fnmatch.fnmatchcase(sub, pat):
                                    new_text = text[:len(text) - i] + repl_eval
                                    if new_text == text:
                                        changed = False
                                        break
                                    text = new_text
                                    changed = True
                                    break
                            if not changed:
                                break
                        return text
                    else:
                        for i in range(1, len(text) + 1):
                            sub = text[len(text) - i:]
                            if fnmatch.fnmatchcase(sub, pat):
                                return text[:len(text) - i] + repl_eval
                        return val

                # Unanchored substitution: use regex built from glob
                pattern = core
                prog = re.compile(pattern, re.DOTALL)
                if is_all:
                    return prog.sub(repl_eval, val)
                else:
                    return prog.sub(repl_eval, val, count=1)

            if rest.startswith(":-"):
                # default if unset or null
                word = rest[2:]
                if (not is_set) or is_null:
                    return Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                return val
            if rest.startswith("-"):
                # default if unset
                word = rest[1:]
                if not is_set:
                    return Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                return val
            if rest.startswith(":+"):
                word = rest[2:]
                if is_set and not is_null:
                    return Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                return ""
            if rest.startswith("+"):
                word = rest[1:]
                if is_set:
                    return Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                return ""
            if rest.startswith(":?"):
                word = rest[2:]
                if (not is_set) or is_null:
                    raise ValueError(Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout) or f"{name}: parameter null or not set")
                return val
            if rest.startswith("?"):
                word = rest[1:]
                if not is_set:
                    raise ValueError(Trying.expand_posix(word, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout) or f"{name}: parameter not set")
                return val

            # No operator: return value or leave original pattern intact
            if is_set:
                return val
            return f"{exp_chr}{{{inner}}}"

        while i < inp_len:
            ch = s[i]

            # Handle backslashes (special for $ and `)
            if ch == esc_chr:
                j = i
                while j < inp_len and s[j] == esc_chr:
                    j += 1
                escape_count = j - i
                if (j < inp_len) and ((s[j] == exp_chr) or (is_bktick_cmd and (s[j] == bktick))):
                    res.append(esc_chr * (escape_count // 2))
                    if (escape_count % 2) == 1:
                        # escaped character -> output literally
                        res.append(s[j])
                        i = j + 1
                        continue
                    # even number -> dollar/backtick not escaped, advance to it
                    i = j
                    continue
                else:
                    res.append(esc_chr * escape_count)
                    i = j
                    continue

            # Handle backtick command substitution
            if is_bktick_cmd and (ch == bktick):
                j = i + 1
                while j < inp_len:
                    if s[j] == bktick:
                        break
                    # allow escaped backticks inside
                    if s[j] == esc_chr and (j + 1) < inp_len and s[j + 1] == bktick:
                        j += 2
                        continue
                    j += 1
                if j >= inp_len:
                    raise ValueError(f"Unterminated backtick command substitution in: {input}")
                inner = s[i + 1:j]
                # expand inner content before executing (propagate flags)
                cmd = Trying.expand_posix(inner, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                if not allow_subprocess:
                    # leave original backtick expression intact
                    res.append(s[i:j + 1])
                    i = j + 1
                    continue
                try:
                    if allow_shell:
                        proc = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=subprocess_timeout)
                    else:
                        proc = subprocess.run(shlex.split(cmd), shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=subprocess_timeout)
                except subprocess.TimeoutExpired:
                    raise ValueError(f"Command substitution timed out: {cmd}")
                if proc.returncode != 0:
                    raise ValueError(f"Command substitution failed: {cmd}: {proc.stderr.strip()}")
                out = proc.stdout.rstrip('\n')
                res.append(out)
                i = j + 1
                continue

            if ch != exp_chr:
                res.append(ch)
                i += 1
                continue

            # $ encountered
            if (i + 1) < inp_len and s[i + 1] == exp_chr:
                res.append(str(os.getpid()))
                i += 2
                continue

            # command substitution: $(...)
            if (i + 1) < inp_len and s[i + 1] == "(":
                j = i + 2
                depth = 1
                while j < inp_len:
                    if s[j] == "(":
                        depth += 1
                    elif s[j] == ")":
                        depth -= 1
                        if depth == 0:
                            break
                    j += 1
                if j >= inp_len:
                    raise ValueError(f"Unterminated command substitution in: {input}")
                inner = s[i + 2:j]
                # expand inner content before executing (propagate flags)
                cmd = Trying.expand_posix(inner, args=args, vars=vars, allow_subprocess=allow_subprocess, allow_shell=allow_shell, subprocess_timeout=subprocess_timeout)
                if not allow_subprocess:
                    # leave original $(...) expression intact
                    res.append(s[i:j + 1])
                    i = j + 1
                    continue
                try:
                    if allow_shell:
                        proc = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=subprocess_timeout)
                    else:
                        proc = subprocess.run(shlex.split(cmd), shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=subprocess_timeout)
                except subprocess.TimeoutExpired:
                    raise ValueError(f"Command substitution timed out: {cmd}")
                if proc.returncode != 0:
                    raise ValueError(f"Command substitution failed: {cmd}: {proc.stderr.strip()}")
                out = proc.stdout.rstrip('\n')
                res.append(out)
                i = j + 1
                continue

            if (i + 1) < inp_len and s[i + 1] == "{":
                # find closing brace accounting for nested braces
                j = i + 2
                depth = 1
                while j < inp_len:
                    if s[j] == "{":
                        depth += 1
                    elif s[j] == "}":
                        depth -= 1
                        if depth == 0:
                            break
                    j += 1
                if j >= inp_len:
                    raise ValueError(f"Unterminated braced expansion in: {input}")
                inner = s[i + 2:j]
                res.append(eval_braced(inner))
                i = j + 1
                continue

            # Unbraced: positional $1 or $name
            j = i + 1
            if j < inp_len and s[j].isdigit():
                start = j
                while j < inp_len and s[j].isdigit():
                    j += 1
                idx = int(s[start:j]) - 1
                if args and 0 <= idx < len(args):
                    res.append(args[idx])
                else:
                    # leave unchanged
                    res.append(s[i:j])
                i = j
                continue

            if j < inp_len and (s[j].isalpha() or s[j] == "_"):
                start = j
                while j < inp_len and (s[j].isalnum() or s[j] == "_"):
                    j += 1
                name = s[start:j]
                val = get_var(name)
                if val is None:
                    res.append(s[i:j])
                else:
                    res.append(val)
                i = j
                continue

            # Nothing matched, treat $ literally
            res.append(exp_chr)
            i += 1

        return "".join(res)

    ###########################################################################

    @staticmethod
    def expand_simple(
        input: str,
        args: list[str] | None = None,
        vars: dict[str, str] | None = None,
        exp_chr: str = "%",
        esc_chr: str = "^",
    ) -> str:
        """
        Perform a simple Windows batch-style expansion on a string.

        Supported features (a minimal subset of cmd.exe semantics):
        - %NAME% expands to environment variable value from `vars` (defaults to os.environ)
        if the variable is not present, the original token is left intact.
        - %1, %2, ... expands to positional arguments provided in `args` (1-based);
        if out of range, the token is left intact.
        - %* expands to all positional arguments joined by a space.
        - %% becomes a single literal '%'.
        - ^ escapes the next character (e.g., ^% produces a literal '%').

        Note: This is not a full implementation of cmd.exe parameter features
        (no FOR-variable handling, no delayed expansion).

        :param input: string to expand
        :param args: positional arguments list (1-based indices)
        :param vars: dictionary with variables (defaults to os.environ)
        :param exp_chr: character marking the expansion start (default: percentage sign)
        :param esc_chr: escaping character (default: cap)
        :return: expanded string
        """

        if input is None:
            return ""

        if vars is None:
            vars = os.environ

        s = input
        i = 0
        ln = len(s)
        out: list[str] = []

        while i < ln:
            ch = s[i]

            # cap escapes next char. Special handling for cap+percent to keep a whole
            # percent-delimited token literal when escaped (so the closing percent is not re-parsed).
            if ch == esc_chr:
                if (i + 1) < ln:
                    nxt = s[i + 1]
                    # If escaping a percent, handle possible forms: %% , %digits , %NAME%
                    if nxt == exp_chr:
                        # If next is '%%' => literal percent char
                        if (i + 2) < ln and s[i + 2] == exp_chr:
                            out.append(exp_chr)
                            i += 3
                            continue
                        # If followed by digit(s): take digits and output literal
                        if (i + 2) < ln and s[i + 2].isdigit():
                            j = i + 2
                            while j < ln and s[j].isdigit():
                                j += 1
                            out.append(exp_chr + s[i + 2:j])
                            i = j
                            continue
                        # If followed by name terminated by percent, make the whole %NAME% literal
                        k = s.find(exp_chr, i + 2)
                        if k != -1:
                            out.append(s[i + 1:k + 1])
                            i = k + 1
                            continue
                        # otherwise, just output a literal percent
                        out.append(exp_chr)
                        i += 2
                        continue
                    # Default: escape next character literally
                    out.append(nxt)
                    i += 2
                    continue
                else:
                    # dangling cap: output as-is
                    out.append(esc_chr)
                    i += 1
                    continue

            if ch != exp_chr:
                out.append(ch)
                i += 1
                continue

            # handle percent-percent -> literal percent
            if (i + 1) < ln and s[i + 1] == exp_chr:
                out.append(exp_chr)
                i += 2
                continue

            # Named variable: %NAME% or modifier form like %~dp1
            j = i + 1
            # modifier form: percent + ~ + mods + DIGITS or percent + ~ + mods + DIGITS + percent
            if j < ln and s[j] == "~":
                k = j + 1
                # collect modifier letters
                mods = []
                while k < ln and s[k].isalpha():
                    mods.append(s[k])
                    k += 1
                # now collect digit index
                if k < ln and s[k].isdigit():
                    start = k
                    while k < ln and s[k].isdigit():
                        k += 1
                    token = s[start:k]
                    end_with_percent = False
                    if k < ln and s[k] == exp_chr:
                        end_with_percent = True
                        k += 1

                    idx = int(token) - 1
                    if args and 0 <= idx < len(args):
                        tokval = args[idx]
                        # compute parts
                        def part_drive(t):
                            return os.path.splitdrive(t)[0]
                        def part_path(t):
                            p = os.path.dirname(t)
                            if p and not p.endswith(os.sep):
                                p = p + os.sep
                            return p
                        def part_name(t):
                            return os.path.splitext(os.path.basename(t))[0]
                        def part_ext(t):
                            return os.path.splitext(t)[1]
                        def part_full(t):
                            return os.path.abspath(t)

                        out_frag = []
                        for m in mods:
                            if m == "d":
                                out_frag.append(part_drive(tokval))
                            elif m == "p":
                                out_frag.append(part_path(tokval))
                            elif m == "n":
                                out_frag.append(part_name(tokval))
                            elif m == "x":
                                out_frag.append(part_ext(tokval))
                            elif m == "f":
                                out_frag.append(part_full(tokval))
                            else:
                                # unknown modifier -> ignore
                                pass
                        out.append("".join(out_frag))
                    else:
                        # leave original token intact
                        if end_with_percent:
                            out.append(exp_chr + s[j:k] + exp_chr)
                        else:
                            out.append(exp_chr + s[j:k])
                    i = k
                    continue

            # if digit or '*' then it's positional
            if j < ln and s[j].isdigit():
                start = j
                while j < ln and s[j].isdigit():
                    j += 1
                # digits are not followed by closing '%' in CMD (they are just %1),
                # but some users may write %1% — support both by allowing an optional '%'
                end_with_percent = False
                if j < ln and s[j] == exp_chr:
                    end_with_percent = True
                    token = s[start:j]
                    j += 1
                else:
                    token = s[start:j]

                idx = int(token) - 1
                if args and 0 <= idx < len(args):
                    out.append(args[idx])
                else:
                    # leave original; include trailing % if present
                    if end_with_percent:
                        out.append(exp_chr + token + exp_chr)
                    else:
                        out.append(exp_chr + token)
                i = j
                continue

            if j < ln and s[j] == "*":
                # %* expands to all args
                j += 1
                if j < ln and s[j] == exp_chr:
                    j += 1
                if args:
                    out.append(" ".join(args))
                else:
                    out.append(exp_chr + "*")
                i = j
                continue

            # Named var: find trailing %
            k = s.find(exp_chr, j)
            if k == -1:
                # no closing %, leave as-is
                out.append(exp_chr)
                i += 1
                continue

            token = s[j:k]
            if not token:
                # empty name -> treat as literal % %
                out.append(exp_chr)
                out.append(exp_chr)
                i = k + 1
                continue

            # Support substring form: NAME:~start[,length]
            # Example: %VAR:~2,3% -> from index 2, length 3
            if ":~" in token:
                base, suff = token.split(":~", 1)
                if not base:
                    out.append(exp_chr + token + exp_chr)
                    i = k + 1
                    continue
                # parse start[,length]
                if "," in suff:
                    start_str, length_str = suff.split(",", 1)
                else:
                    start_str = suff
                    length_str = None
                try:
                    start = int(start_str)
                    length = int(length_str) if (length_str is not None and length_str != "") else None
                except Exception:
                    out.append(exp_chr + token + exp_chr)
                    i = k + 1
                    continue

                val = vars.get(base)
                if val is None:
                    out.append(exp_chr + token + exp_chr)
                    i = k + 1
                    continue

                text = val
                if start < 0:
                    start = len(text) + start
                    if start < 0:
                        start = 0
                if length is None:
                    substr = text[start:]
                else:
                    if length < 0:
                        substr = ""
                    else:
                        substr = text[start:start + length]
                out.append(substr)
                i = k + 1
                continue

            name = token
            val = vars.get(name)
            if val is None:
                # leave untouched: include the surrounding %
                out.append(exp_chr + name + exp_chr)
            else:
                out.append(val)

            i = k + 1

        return "".join(out)


###############################################################################
